resources/chromium/webxr-test.js:		// Implements XRFrameDataProvider and XRPresentationProvider. Maintains a mock
resources/chromium/webxr-test.js:		  // XRFrameDataProvider implementation.
resources/chromium/webxr-test.js:		        const dataProviderPtr = new vrMojom.XRFrameDataProviderRemote();
resources/chromium/webxr-test.js:		            new vrMojom.XRFrameDataProviderReceiver(this);
video-rvfc/request-video-frame-callback-before-xr-session.https.html:		    function onXRFrame(time, frame) {
video-rvfc/request-video-frame-callback-before-xr-session.https.html:		        session.requestAnimationFrame(onXRFrame);
video-rvfc/request-video-frame-callback-before-xr-session.https.html:		    session.requestAnimationFrame(onXRFrame);
video-rvfc/request-video-frame-callback-during-xr-session.https.html:		    function onXRFrame(time, frame) {
video-rvfc/request-video-frame-callback-during-xr-session.https.html:		        session.requestAnimationFrame(onXRFrame);
video-rvfc/request-video-frame-callback-during-xr-session.https.html:		    session.requestAnimationFrame(onXRFrame);
webxr/anchors/ar_anchor_getAnchors.https.html:		// Attempts to access XRFrame.trackedAnchors and expects to get empty set
webxr/anchors/ar_anchor_getAnchors.https.html:		xr_session_promise_test("XRFrame's trackedAnchors is empty when the feature was not requested",
webxr/anchors/ar_anchor_getAnchors.https.html:		xr_session_promise_test("XRFrame's trackedAnchors is empty when the feature was requested",
webxr/depth-sensing/depth_sensing_notEnabled.https.html:		  "XRFrame.getDepthInformation() rejects if depth sensing is not enabled on a session",
webxr/depth-sensing/gpu/depth_sensing_gpu_incorrectUsage.https.html:		                            "XRFrame.getDepthInformation() should throw when depth sensing is in `gpu-optimized` usage mode");
webxr/dom-overlay/ar_dom_overlay.https.html:		    session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		    requestSkipAnimationFrame(session, (time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		      session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		        session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		          session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		            session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		              session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		                session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		    requestSkipAnimationFrame(session, (time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		      session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		        session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		          session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		            session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		              session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay.https.html:		                session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay_hit_test.https.html:		        session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay_hit_test.https.html:		          session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay_hit_test.https.html:		            const results = xrFrame.getHitTestResultsForTransientInput(hitTestSource);
webxr/dom-overlay/ar_dom_overlay_hit_test.https.html:		            session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay_hit_test.https.html:		              session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay_hit_test.https.html:		                session.requestAnimationFrame((time, xrFrame) => {
webxr/dom-overlay/ar_dom_overlay_hit_test.https.html:		                  const results = xrFrame.getHitTestResultsForTransientInput(hitTestSource);
webxr/events_input_source_recreation.https.html:		  session.requestAnimationFrame((time, xrFrame) => {
webxr/events_input_source_recreation.https.html:		    session.requestAnimationFrame((time, xrFrame) => {
webxr/events_input_source_recreation.https.html:		      session.requestAnimationFrame((time, xrFrame) => {
webxr/events_input_source_recreation.https.html:		        session.requestAnimationFrame((time, xrFrame) => {
webxr/events_input_source_recreation.https.html:		          session.requestAnimationFrame((time, xrFrame) => {});
webxr/events_input_sources_change.https.html:		  requestSkipAnimationFrame(session, (time, xrFrame) => {
webxr/events_input_sources_change.https.html:		    session.requestAnimationFrame((time, xrFrame) => {});
webxr/events_session_select.https.html:		      requestSkipAnimationFrame(session, (time, xrFrame) => {
webxr/events_session_select.https.html:		          session.requestAnimationFrame((time, xrFrame) => {
webxr/events_session_select.https.html:		            session.requestAnimationFrame((time, xrFrame) => {
webxr/events_session_select_subframe.https.html:		  requestSkipAnimationFrame(session, (time, xrFrame) => {
webxr/events_session_select_subframe.https.html:		    session.requestAnimationFrame((time, xrFrame) => {
webxr/events_session_squeeze.https.html:		      requestSkipAnimationFrame(session, (time, xrFrame) => {
webxr/events_session_squeeze.https.html:		          session.requestAnimationFrame((time, xrFrame) => {
webxr/events_session_squeeze.https.html:		            session.requestAnimationFrame((time, xrFrame) => {
webxr/getInputPose_handedness.https.html:		    function CheckNone(time, xrFrame) {
webxr/getInputPose_handedness.https.html:		    function CheckRight(time, xrFrame) {
webxr/getInputPose_handedness.https.html:		    function CheckLeft(time, xrFrame) {
webxr/getInputPose_handedness.https.html:		    function CheckNoneAgain(time, xrFrame) {
webxr/getInputPose_pointer.https.html:		      function CheckInvalidGrip(time, xrFrame) {
webxr/getInputPose_pointer.https.html:		        let grip_pose = xrFrame.getPose(source.gripSpace, referenceSpace);
webxr/getInputPose_pointer.https.html:		      function CheckValidGrip(time, xrFrame) {
webxr/getInputPose_pointer.https.html:		        let grip_pose = xrFrame.getPose(source.gripSpace, referenceSpace);
webxr/getInputPose_pointer.https.html:		        let input_pose = xrFrame.getPose(source.targetRaySpace, referenceSpace);
webxr/getInputPose_pointer.https.html:		      function CheckValidGripAndPointer(time, xrFrame) {
webxr/getInputPose_pointer.https.html:		        let grip_pose = xrFrame.getPose(source.gripSpace, referenceSpace);
webxr/getInputPose_pointer.https.html:		        let input_pose = xrFrame.getPose(source.targetRaySpace, referenceSpace);
webxr/getViewerPose_emulatedPosition.https.html:		    let testName = "XRFrame getViewerPose has emulatedPosition set properly.";
webxr/hit-test/idlharness.https.html:		        // TODO: XRFrame
webxr/idlharness.https.window.js:		      // TODO: XRFrame
webxr/navigator_xr_sameObject.https.html:		    session.requestAnimationFrame((time, xrFrame) => {
webxr/navigator_xr_sameObject.https.html:		      session.requestAnimationFrame((time, xrFrame) => {
webxr/render_state_update.https.html:		        session.requestAnimationFrame((time, xrFrame) => {
webxr/render_state_update.https.html:		            session.requestAnimationFrame((time, xrFrame) => {
webxr/resources/webxr_util.js:		  callback(window.XRFrameRequestCallback, 'XRFrameRequestCallback');
webxr/resources/webxr_util.js:		  callback(window.XRFrame, 'XRFrame');
webxr/resources/webxr_util.js:		  callback(window.XRFrameOfReference, 'XRFrameOfReference');
webxr/xrBoundedReferenceSpace_updates.https.html:		          function onFrame(time, xrFrame) {
webxr/xrFrame_getPose.https.html:		let immersiveTestName = "XRFrame.getPose works for immersive sessions";
webxr/xrFrame_getPose.https.html:		let nonImmersiveTestName = "XRFrame.getPose works for non-immersive sessions";
webxr/xrFrame_getPose.https.html:		    function onFrame(time, xrFrame) {
webxr/xrFrame_getPose.https.html:		      let translated_from_base = xrFrame.getPose(translatedSpace1, space1);
webxr/xrFrame_getPose.https.html:		      let space2_from_space1 = xrFrame.getPose(space1, space2);
webxr/xrFrame_getViewerPose_getPose.https.html:		    let testName = "XRFrame getViewerPose(refSpace) matches getPose(viewer, refSpace).";
webxr/xrFrame_getViewerPose_getPose_identities.https.html:		    let testName = "XRFrame getViewerPose(viewerSpace) & getPose(space, space) return identity even during tracking loss";
webxr/xrFrame_lifetime.https.html:		    let immersiveTestName = "XRFrame methods throw exceptions outside of the " +
webxr/xrFrame_lifetime.https.html:		    let nonImmersiveTestName = "XRFrame methods throw exceptions outside of the " +
webxr/xrFrame_lifetime.https.html:		      function onFrame(time, xrFrame) {
webxr/xrFrame_lifetime.https.html:		          assert_true(xrFrame instanceof XRFrame);
webxr/xrFrame_lifetime.https.html:		        staleFrame = xrFrame;
webxr/xrFrame_session_sameObject.https.html:		let testName = "XRFrame.session meets [SameObject] requirement";
webxr/xrFrame_session_sameObject.https.html:		    session.requestAnimationFrame((time, xrFrame) => {
webxr/xrFrame_session_sameObject.https.html:		      let session = xrFrame.session;
webxr/xrFrame_session_sameObject.https.html:		        assert_equals(session, xrFrame.session,
webxr/xrFrame_session_sameObject.https.html:		          "XRFrame.session returns the same object.");
webxr/xrInputSource_add_remove.https.html:		    requestSkipAnimationFrame(session, (time, xrFrame) => {
webxr/xrInputSource_add_remove.https.html:		      session.requestAnimationFrame((time, xrFrame) => {
webxr/xrInputSource_add_remove.https.html:		        session.requestAnimationFrame((time, xrFrame) => {
webxr/xrInputSource_emulatedPosition.https.html:		      function CheckPositionNotEmulated(time, xrFrame) {
webxr/xrInputSource_emulatedPosition.https.html:		        let grip_pose = xrFrame.getPose(source.gripSpace, referenceSpace);
webxr/xrInputSource_emulatedPosition.https.html:		      function CheckPositionEmulated(time, xrFrame) {
webxr/xrInputSource_emulatedPosition.https.html:		        let grip_pose = xrFrame.getPose(source.gripSpace, referenceSpace);
webxr/xrInputSource_getPose_targetRay_grip.https.html:		    function CheckPoseBetweenTargetRayAndGripSpaces(time, xrFrame) {
webxr/xrInputSource_getPose_targetRay_grip.https.html:		      let target_ray_space_from_grip_space = xrFrame.getPose(source.gripSpace, source.targetRaySpace);
webxr/xrInputSource_sameObject.https.html:		    requestSkipAnimationFrame(session, (time, xrFrame) => {
webxr/xrInputSource_sameObject.https.html:		      session.requestAnimationFrame((time, xrFrame) => {
webxr/xrPose_transform_sameObject.https.html:		      requestSkipAnimationFrame(session, (time, xrFrame) => {
webxr/xrPose_transform_sameObject.https.html:		        let input_pose = xrFrame.getPose(source.targetRaySpace, referenceSpace);
webxr/xrReferenceSpace_relationships.https.html:		      const onFrame = function(time, xrFrame) {
webxr/xrReferenceSpace_relationships.https.html:		        const localFloorPoseInLocalSpace = xrFrame.getPose(localFloorSpace, localSpace);
webxr/xrReferenceSpace_relationships.https.html:		        const viewerPoseInLocalFloorSpace = xrFrame.getPose(viewerSpace, localFloorSpace);
webxr/xrReferenceSpace_relationships.https.html:		        const boundedFloorPoseInLocalFloorSpace = xrFrame.getPose(boundedSpace, localFloorSpace);
webxr/xrSession_requestAnimationFrame_callback_calls.https.html:		      function onFrame(time, xrFrame) {
webxr/xrSession_requestAnimationFrame_callback_calls.https.html:		        assert_true(xrFrame instanceof XRFrame);
webxr/xrSession_requestAnimationFrame_data_valid.https.html:		          function onFrame(time, xrFrame) {
webxr/xrSession_requestAnimationFrame_data_valid.https.html:		            assert_true(xrFrame instanceof XRFrame);
webxr/xrSession_requestAnimationFrame_data_valid.https.html:		            let viewerPose = xrFrame.getViewerPose(referenceSpace);
webxr/xrSession_requestAnimationFrame_getViewerPose.https.html:		      "XRFrame getViewerPose updates on the next frame for immersive sessions";
webxr/xrSession_requestAnimationFrame_getViewerPose.https.html:		      "XRFrame getViewerPose updates on the next frame for non-immersive sessions";
webxr/xrSession_requestAnimationFrame_timestamp.https.html:		let immersiveTestName = "XRFrame getViewerPose updates on the next frame for immersive";
webxr/xrSession_requestAnimationFrame_timestamp.https.html:		let nonImmersiveTestName = "XRFrame getViewerPose updates on the next frame for non-immersive";
webxr/xrSession_requestAnimationFrame_timestamp.https.html:		      function onFrameFirst(time, xrFrame) {
webxr/xrSession_requestAnimationFrame_timestamp.https.html:		      function onFrameSubsequent(time, xrFrame) {
webxr/xrSession_requestAnimationFrame_timestamp.https.html:		      function onFrameLast(time, xrFrame) {
webxr/xrSession_sameObject.https.html:		    requestSkipAnimationFrame(session, (time, xrFrame) => {
webxr/xrSession_sameObject.https.html:		      session.requestAnimationFrame((time, xrFrame) => {
webxr/xrSession_sameObject.https.html:		        session.requestAnimationFrame((time, xrFrame) => {
webxr/xrSession_viewer_referenceSpace.https.html:		          function onFrame(time, xrFrame) {
webxr/xrSession_viewer_referenceSpace.https.html:		                let pose = xrFrame.getViewerPose(referenceSpace);
webxr/xrSession_viewer_referenceSpace.https.html:		                let pose = xrFrame.getViewerPose(referenceSpace);
webxr/xrStationaryReferenceSpace_floorlevel_updates.https.html:		      function onFirstFrame(time, xrFrame) {
webxr/xrStationaryReferenceSpace_floorlevel_updates.https.html:		          let pose = xrFrame.getViewerPose(referenceSpace);
webxr/xrStationaryReferenceSpace_floorlevel_updates.https.html:		      function onFrame(time, xrFrame) {
webxr/xrStationaryReferenceSpace_floorlevel_updates.https.html:		          let pose = xrFrame.getViewerPose(referenceSpace);
webxr/xrView_eyes.https.html:		    function onFrame(time, xrFrame) {
webxr/xrView_eyes.https.html:		      let viewer_pose = xrFrame.getViewerPose(space);
webxr/xrView_match.https.html:		let testName = "XRFrame contains the expected views";
webxr/xrView_match.https.html:		      function onFrame(time, xrFrame) {
webxr/xrView_match.https.html:		        let pose = xrFrame.getViewerPose(referenceSpace);
webxr/xrView_match.https.html:		          let pose2 = xrFrame.getPose(viewerSpace, referenceSpace);
webxr/xrView_oneframeupdate.https.html:		      function onFrame(time, xrFrame) {
webxr/xrView_oneframeupdate.https.html:		        let pose = xrFrame.getViewerPose(referenceSpace);
webxr/xrView_sameObject.https.html:		      session.requestAnimationFrame((time, xrFrame) => {
webxr/xrView_sameObject.https.html:		        let viewerPose = xrFrame.getViewerPose(referenceSpace);
webxr/xrViewerPose_secondaryViews.https.html:		      function onFrame(time, xrFrame) {
webxr/xrViewerPose_secondaryViews.https.html:		          let pose = xrFrame.getViewerPose(referenceSpace);
webxr/xrViewerPose_views_sameObject.https.html:		      session.requestAnimationFrame((time, xrFrame) => {
webxr/xrViewerPose_views_sameObject.https.html:		        let viewerPose = xrFrame.getViewerPose(referenceSpace);
webxr/xrViewport_valid.https.html:		      function onFrame(time, xrFrame) {
webxr/xrViewport_valid.https.html:		          let pose = xrFrame.getViewerPose(referenceSpace);
webxr/xrWebGLLayer_framebuffer_draw.https.html:		  let xrFramebuffer = webglLayer.framebuffer;
webxr/xrWebGLLayer_framebuffer_draw.https.html:		    gl.bindFramebuffer(gl.FRAMEBUFFER, xrFramebuffer);
webxr/xrWebGLLayer_framebuffer_draw.https.html:		  session.requestAnimationFrame((time, xrFrame) => {
webxr/xrWebGLLayer_opaque_framebuffer.https.html:		  let xrFramebuffer = webglLayer.framebuffer;
webxr/xrWebGLLayer_opaque_framebuffer.https.html:		    assert_equals(xrFramebuffer, null);
webxr/xrWebGLLayer_opaque_framebuffer.https.html:		  assert_not_equals(xrFramebuffer, null);
webxr/xrWebGLLayer_opaque_framebuffer.https.html:		  assert_not_equals(xrFramebuffer, gl.getParameter(gl.FRAMEBUFFER_BINDING));
webxr/xrWebGLLayer_opaque_framebuffer.https.html:		  gl.bindFramebuffer(gl.FRAMEBUFFER, xrFramebuffer);
webxr/xrWebGLLayer_opaque_framebuffer.https.html:		  gl.deleteFramebuffer(xrFramebuffer);
webxr/xrWebGLLayer_opaque_framebuffer.https.html:		  assert_equals(xrFramebuffer, boundFramebuffer);
webxr/xrWebGLLayer_opaque_framebuffer.https.html:		  session.requestAnimationFrame((time, xrFrame) => {
webxr/xrWebGLLayer_opaque_framebuffer_stencil.https.html:		  const xrFramebuffer = webglLayer.framebuffer;
webxr/xrWebGLLayer_opaque_framebuffer_stencil.https.html:		  session.requestAnimationFrame((time, xrFrame) => {
webxr/xrWebGLLayer_opaque_framebuffer_stencil.https.html:		        assert_equals(xrFramebuffer, null, 'inline, fbo = null');
webxr/xrWebGLLayer_opaque_framebuffer_stencil.https.html:		        // xrFramebuffer is null.
webxr/xrWebGLLayer_opaque_framebuffer_stencil.https.html:		        gl.bindFramebuffer(gl.FRAMEBUFFER, xrFramebuffer);
webxr/xrWebGLLayer_opaque_framebuffer_stencil.https.html:		        assert_not_equals(xrFramebuffer, null, 'immersive, fbo != null');
webxr/xrWebGLLayer_opaque_framebuffer_stencil.https.html:		        gl.bindFramebuffer(gl.FRAMEBUFFER, xrFramebuffer);
webxr/xrWebGLLayer_viewports.https.html:		    function onFrame(time, xrFrame) {
webxr/xrWebGLLayer_viewports.https.html:		      let viewer_pose = xrFrame.getViewerPose(space);
webxr/xrWebGLLayer_viewports.https.html:		      let layer = xrFrame.session.renderState.baseLayer;
webxr/xr_viewport_scale.https.html:		    function onFrame(time, xrFrame1) {
webxr/xr_viewport_scale.https.html:		      let layer = xrFrame1.session.renderState.baseLayer;
webxr/xr_viewport_scale.https.html:		      let views1 = xrFrame1.getViewerPose(space).views;
webxr/xr_viewport_scale.https.html:		        session.requestAnimationFrame((time, xrFrame2) =>
webxr/xr_viewport_scale.https.html:		          nextFrame(name, t, session, space, layer, fullViewports, xrFrame2, resolve));
webxr/xr_viewport_scale.https.html:		let testViewportValid = function(name, t, session, space, layer, fullViewports, xrFrame, resolve) {
webxr/xr_viewport_scale.https.html:		  let views = xrFrame.getViewerPose(space).views;
webxr/xr_viewport_scale.https.html:		let testScaleAppliedNextFrame = function(name, t, session, space, layer, fullViewports, xrFrame, resolve) {
webxr/xr_viewport_scale.https.html:		  let views = xrFrame.getViewerPose(space).views;
webxr/xr_viewport_scale.https.html:		let testScaleSameFrame = function(name, t, session, space, layer, fullViewports, xrFrame, resolve) {
webxr/xr_viewport_scale.https.html:		  let views = xrFrame.getViewerPose(space).views;
webxr/xr_viewport_scale.https.html:		  session.requestAnimationFrame((time, xrFrame3) => {
webxr/xr_viewport_scale.https.html:		    let views3 = xrFrame3.getViewerPose(space).views;
webxr/xr_viewport_scale.https.html:		let testRecommendedScale = function(name, t, session, space, layer, fullViewports, xrFrame, resolve) {
webxr/xr_viewport_scale.https.html:		  let views = xrFrame.getViewerPose(space).views;
